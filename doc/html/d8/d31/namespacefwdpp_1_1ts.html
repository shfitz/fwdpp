<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fwdpp: fwdpp::ts Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.7.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/d84/namespacefwdpp.html">fwdpp</a></li><li class="navelem"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html">ts</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">fwdpp::ts Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Tree sequence <a class="el" href="../../d0/de3/citelist.html#CITEREF_Kelleher2018-fu">[2]</a> support.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d0/d89/namespacefwdpp_1_1ts_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/namespacefwdpp_1_1ts_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/d5d/namespacefwdpp_1_1ts_1_1io"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5d/namespacefwdpp_1_1ts_1_1io.html">io</a></td></tr>
<tr class="memdesc:da/d5d/namespacefwdpp_1_1ts_1_1io"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary seriazliation of <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">fwdpp::ts::table_collection</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d48/structfwdpp_1_1ts_1_1all__mutations.html">all_mutations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An edge in a tree sequence.  <a href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d1b/structfwdpp_1_1ts_1_1indexed__edge.html">indexed_edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-recombining tree.  <a href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d54/structfwdpp_1_1ts_1_1mut__rec__intermediates.html">mut_rec_intermediates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de4/structfwdpp_1_1ts_1_1selected__variants__only.html">selected_variants_only</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of tables for a single simulation.  <a href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0a/classfwdpp_1_1ts_1_1table__simplifier.html">table_simplifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the simplification algorithm of <a class="el" href="../../d0/de3/citelist.html#CITEREF_Kelleher2018-fu">[2]</a>.  <a href="../../dc/d0a/classfwdpp_1_1ts_1_1table__simplifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d8f/classfwdpp_1_1ts_1_1tree__visitor.html">tree_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that iterates over marginal trees.  <a href="../../df/d8f/classfwdpp_1_1ts_1_1tree__visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af35a0875d0656933d78cc7840a662aa5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> = std::int32_t</td></tr>
<tr class="memdesc:af35a0875d0656933d78cc7840a662aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer type for node indexes.  <a href="#af35a0875d0656933d78cc7840a662aa5">More...</a><br /></td></tr>
<tr class="separator:af35a0875d0656933d78cc7840a662aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8aa2800d3ad3222f919e113cac33706"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#ab8aa2800d3ad3222f919e113cac33706">indexed_edge_container</a> = std::vector&lt; <a class="el" href="../../d6/d1b/structfwdpp_1_1ts_1_1indexed__edge.html">indexed_edge</a> &gt;</td></tr>
<tr class="separator:ab8aa2800d3ad3222f919e113cac33706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3b5522130bcd6ca8feeb86276b0807"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#aff3b5522130bcd6ca8feeb86276b0807">edge_vector</a> = std::vector&lt; <a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a> &gt;</td></tr>
<tr class="separator:aff3b5522130bcd6ca8feeb86276b0807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c51e69b27f3e160eb62ea06591a2bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a60c51e69b27f3e160eb62ea06591a2bb">node_vector</a> = std::vector&lt; <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a> &gt;</td></tr>
<tr class="separator:a60c51e69b27f3e160eb62ea06591a2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fa9d4b0f7f967c76a8d550102a7405"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a37fa9d4b0f7f967c76a8d550102a7405">mutation_key_vector</a> = std::vector&lt; <a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a> &gt;</td></tr>
<tr class="separator:a37fa9d4b0f7f967c76a8d550102a7405"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a22d368f93651e5db0700a824bc76f902"><td class="memTemplParams" colspan="2">template&lt;typename mcont_t &gt; </td></tr>
<tr class="memitem:a22d368f93651e5db0700a824bc76f902"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a22d368f93651e5db0700a824bc76f902">count_mutations</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, const mcont_t &amp;mutations, const std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt; &amp;samples, std::vector&lt; <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> &gt; &amp;mcounts)</td></tr>
<tr class="separator:a22d368f93651e5db0700a824bc76f902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dbef728e90e485682815dc59ce08b5"><td class="memTemplParams" colspan="2">template&lt;typename mcont_t &gt; </td></tr>
<tr class="memitem:af2dbef728e90e485682815dc59ce08b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af2dbef728e90e485682815dc59ce08b5">count_mutations</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, const mcont_t &amp;mutations, const std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt; &amp;samples, std::vector&lt; <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> &gt; &amp;mcounts, std::vector&lt; <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> &gt; &amp;acounts)</td></tr>
<tr class="separator:af2dbef728e90e485682815dc59ce08b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df8628a86608fa402ff6430fc387408"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a1df8628a86608fa402ff6430fc387408">operator==</a> (const <a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a> &amp;a, const <a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a> &amp;b)</td></tr>
<tr class="separator:a1df8628a86608fa402ff6430fc387408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8596f5ad2ff4c7674476e802c285de25"><td class="memTemplParams" colspan="2">template&lt;typename mcont_t &gt; </td></tr>
<tr class="memitem:a8596f5ad2ff4c7674476e802c285de25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dd/d3a/structfwdpp_1_1data__matrix.html">data_matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a8596f5ad2ff4c7674476e802c285de25">generate_data_matrix</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, const std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt; &amp;samples, const mcont_t &amp;mutations, const bool record_neutral, const bool record_selected, const bool skip_fixed, const double start, const double stop)</td></tr>
<tr class="separator:a8596f5ad2ff4c7674476e802c285de25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bc26c40b07c456d114a8ebaa0008ff"><td class="memTemplParams" colspan="2">template&lt;typename mcont_t &gt; </td></tr>
<tr class="memitem:a23bc26c40b07c456d114a8ebaa0008ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dd/d3a/structfwdpp_1_1data__matrix.html">data_matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a23bc26c40b07c456d114a8ebaa0008ff">generate_data_matrix</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, const std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt; &amp;samples, const mcont_t &amp;mutations, const bool record_neutral, const bool record_selected, const bool skip_fixed)</td></tr>
<tr class="separator:a23bc26c40b07c456d114a8ebaa0008ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acb8ff641b41bc320a54cbcf9aa29a3"><td class="memTemplParams" colspan="2">template&lt;typename genetic_param_holder , typename mutation_handling_policy , typename poptype &gt; </td></tr>
<tr class="memitem:a8acb8ff641b41bc320a54cbcf9aa29a3"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d2/d54/structfwdpp_1_1ts_1_1mut__rec__intermediates.html">mut_rec_intermediates</a>, <a class="el" href="../../d2/d54/structfwdpp_1_1ts_1_1mut__rec__intermediates.html">mut_rec_intermediates</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a8acb8ff641b41bc320a54cbcf9aa29a3">generate_offspring</a> (const gsl_rng *r, const std::pair&lt; std::size_t, std::size_t &gt; parents, const mutation_handling_policy &amp;mutation_policy, <a class="el" href="../../d2/df8/spatialts_8cc.html#a7772591e7f617e52a048394158fd7302">poptype</a> &amp;pop, genetic_param_holder &amp;genetics, typename <a class="el" href="../../d5/d60/classfwdpp_1_1poptypes_1_1slocuspop.html#a77c390c6b7f108b758f9169d9c6664a6">poptype::diploid_t</a> &amp;offspring)</td></tr>
<tr class="memdesc:a8acb8ff641b41bc320a54cbcf9aa29a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate offspring gametes and return breakpoints plus mutation keys.  <a href="#a8acb8ff641b41bc320a54cbcf9aa29a3">More...</a><br /></td></tr>
<tr class="separator:a8acb8ff641b41bc320a54cbcf9aa29a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116196377f3b3675bd12951dca7241f3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>, <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a116196377f3b3675bd12951dca7241f3">get_parent_ids</a> (const <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> first_parental_index, const <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> parent, const int did_swap)</td></tr>
<tr class="separator:a116196377f3b3675bd12951dca7241f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1a2cf7567e8754360c59943adbe18b"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>, std::vector&lt; std::pair&lt; double, double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a0e1a2cf7567e8754360c59943adbe18b">mark_multiple_roots</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, const std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt; &amp;samples)</td></tr>
<tr class="memdesc:a0e1a2cf7567e8754360c59943adbe18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify root nodes in "marginal forests".  <a href="#a0e1a2cf7567e8754360c59943adbe18b">More...</a><br /></td></tr>
<tr class="separator:a0e1a2cf7567e8754360c59943adbe18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1016e433a6b6390ae0b705cf61dfb1cc"><td class="memTemplParams" colspan="2">template&lt;typename rng , typename mfunction &gt; </td></tr>
<tr class="memitem:a1016e433a6b6390ae0b705cf61dfb1cc"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a1016e433a6b6390ae0b705cf61dfb1cc">mutate_tables</a> (const rng &amp;r, const mfunction &amp;make_mutation, <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, const std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt; &amp;samples, const double mu)</td></tr>
<tr class="memdesc:a1016e433a6b6390ae0b705cf61dfb1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a mutation scheme to add neutral mutations to a <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">fwdpp::ts::table_collection</a>.  <a href="#a1016e433a6b6390ae0b705cf61dfb1cc">More...</a><br /></td></tr>
<tr class="separator:a1016e433a6b6390ae0b705cf61dfb1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f05170560f56c1ac6316db842127ba6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a5f05170560f56c1ac6316db842127ba6">operator==</a> (const <a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a> &amp;a, const <a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a> &amp;b)</td></tr>
<tr class="separator:a5f05170560f56c1ac6316db842127ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dd878eb29e8e1b1fb09e0471f603f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a96dd878eb29e8e1b1fb09e0471f603f4">operator==</a> (const <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a> &amp;a, const <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a> &amp;b)</td></tr>
<tr class="separator:a96dd878eb29e8e1b1fb09e0471f603f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7bf711e7bba2ce46c4cc64c313309e"><td class="memItemLeft" align="right" valign="top">flagged_mutation_queue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a4e7bf711e7bba2ce46c4cc64c313309e">make_mut_queue</a> (const std::vector&lt; std::uint32_t &gt; &amp;mcounts, const std::vector&lt; std::uint32_t &gt; &amp;counts_from_preserved_nodes)</td></tr>
<tr class="memdesc:a4e7bf711e7bba2ce46c4cc64c313309e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a mutation recycling queue for simulations with tree sequences.  <a href="#a4e7bf711e7bba2ce46c4cc64c313309e">More...</a><br /></td></tr>
<tr class="separator:a4e7bf711e7bba2ce46c4cc64c313309e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ee3318265e92ca462eb292a91d883a"><td class="memItemLeft" align="right" valign="top">flagged_mutation_queue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a90ee3318265e92ca462eb292a91d883a">make_mut_queue</a> (std::vector&lt; std::size_t &gt; &amp;preserved_mutation_indexes, const std::size_t num_mutations)</td></tr>
<tr class="memdesc:a90ee3318265e92ca462eb292a91d883a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a mutation recycling queue for simulations with tree sequences.  <a href="#a90ee3318265e92ca462eb292a91d883a">More...</a><br /></td></tr>
<tr class="separator:a90ee3318265e92ca462eb292a91d883a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31b6eea1568ee4866fc66bae4be31ef"><td class="memTemplParams" colspan="2">template&lt;typename poptype , typename mutation_count_container , typename preserve_selected_fixations , typename record_fixations &gt; </td></tr>
<tr class="memitem:af31b6eea1568ee4866fc66bae4be31ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af31b6eea1568ee4866fc66bae4be31ef">flag_mutations_for_recycling</a> (<a class="el" href="../../d2/df8/spatialts_8cc.html#a7772591e7f617e52a048394158fd7302">poptype</a> &amp;pop, mutation_count_container &amp;mcounts_from_preserved_nodes, const <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">uint_t</a> twoN, const <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">uint_t</a> generation, const preserve_selected_fixations preserve, const record_fixations record)</td></tr>
<tr class="separator:af31b6eea1568ee4866fc66bae4be31ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cfaa436a43ae3e8f4ddaee5fac395e"><td class="memTemplParams" colspan="2">template&lt;typename gcont_t , typename mcont_t , typename mutation_count_container &gt; </td></tr>
<tr class="memitem:a98cfaa436a43ae3e8f4ddaee5fac395e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a98cfaa436a43ae3e8f4ddaee5fac395e">remove_fixations_from_gametes</a> (gcont_t &amp;gametes, const mcont_t &amp;mutations, const mutation_count_container &amp;mcounts, const mutation_count_container &amp;mcounts_from_preserved_nodes, const <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> twoN, const bool preserve_selected_fixations)</td></tr>
<tr class="memdesc:a98cfaa436a43ae3e8f4ddaee5fac395e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removed fixed variants from gametes.  <a href="#a98cfaa436a43ae3e8f4ddaee5fac395e">More...</a><br /></td></tr>
<tr class="separator:a98cfaa436a43ae3e8f4ddaee5fac395e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79321c58c8dec2eabbb073b689bf4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a4e79321c58c8dec2eabbb073b689bf4e">operator==</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;a, const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;b)</td></tr>
<tr class="separator:a4e79321c58c8dec2eabbb073b689bf4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab382753de993cedb4e1d14c152868446"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#ab382753de993cedb4e1d14c152868446">operator!=</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;a, const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;b)</td></tr>
<tr class="separator:ab382753de993cedb4e1d14c152868446"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3b6e884129b83242fc56f14784a2a3d8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a3b6e884129b83242fc56f14784a2a3d8">TS_NULL_NODE</a> = -1</td></tr>
<tr class="memdesc:a3b6e884129b83242fc56f14784a2a3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index value of a NULL node.  <a href="#a3b6e884129b83242fc56f14784a2a3d8">More...</a><br /></td></tr>
<tr class="separator:a3b6e884129b83242fc56f14784a2a3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Tree sequence <a class="el" href="../../d0/de3/citelist.html#CITEREF_Kelleher2018-fu">[2]</a> support. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aff3b5522130bcd6ca8feeb86276b0807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3b5522130bcd6ca8feeb86276b0807">&#9670;&nbsp;</a></span>edge_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#aff3b5522130bcd6ca8feeb86276b0807">fwdpp::ts::edge_vector</a> = typedef std::vector&lt;<a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An "edge table" </p><dl class="section version"><dt>Version</dt><dd>0.7.0 Added to fwdpp </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/d70/table__collection_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../d3/d70/table__collection_8hpp_source.html">table_collection.hpp</a>.</p>

</div>
</div>
<a id="ab8aa2800d3ad3222f919e113cac33706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8aa2800d3ad3222f919e113cac33706">&#9670;&nbsp;</a></span>indexed_edge_container</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#ab8aa2800d3ad3222f919e113cac33706">fwdpp::ts::indexed_edge_container</a> = typedef std::vector&lt;<a class="el" href="../../d6/d1b/structfwdpp_1_1ts_1_1indexed__edge.html">indexed_edge</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An index for an edge table. See <a class="el" href="../../d0/de3/citelist.html#CITEREF_Kelleher2016-cb">[1]</a>, page 13</p><dl class="section version"><dt>Version</dt><dd>0.7.0 Added to fwdpp </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/db6/indexed__edge_8hpp_source.html#l00038">38</a> of file <a class="el" href="../../d8/db6/indexed__edge_8hpp_source.html">indexed_edge.hpp</a>.</p>

</div>
</div>
<a id="a37fa9d4b0f7f967c76a8d550102a7405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fa9d4b0f7f967c76a8d550102a7405">&#9670;&nbsp;</a></span>mutation_key_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a37fa9d4b0f7f967c76a8d550102a7405">fwdpp::ts::mutation_key_vector</a> = typedef std::vector&lt;<a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A "mutation table" </p><dl class="section version"><dt>Version</dt><dd>0.7.0 Added to fwdpp </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/d70/table__collection_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../d3/d70/table__collection_8hpp_source.html">table_collection.hpp</a>.</p>

</div>
</div>
<a id="a60c51e69b27f3e160eb62ea06591a2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c51e69b27f3e160eb62ea06591a2bb">&#9670;&nbsp;</a></span>node_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a60c51e69b27f3e160eb62ea06591a2bb">fwdpp::ts::node_vector</a> = typedef std::vector&lt;<a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A "node table" </p><dl class="section version"><dt>Version</dt><dd>0.7.0 Added to fwdpp </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/d70/table__collection_8hpp_source.html#l00028">28</a> of file <a class="el" href="../../d3/d70/table__collection_8hpp_source.html">table_collection.hpp</a>.</p>

</div>
</div>
<a id="af35a0875d0656933d78cc7840a662aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35a0875d0656933d78cc7840a662aa5">&#9670;&nbsp;</a></span>TS_NODE_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">fwdpp::ts::TS_NODE_INT</a> = typedef std::int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer type for node indexes. </p>

<p class="definition">Definition at line <a class="el" href="../../d1/dc9/definitions_8hpp_source.html#l00013">13</a> of file <a class="el" href="../../d1/dc9/definitions_8hpp_source.html">definitions.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a22d368f93651e5db0700a824bc76f902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d368f93651e5db0700a824bc76f902">&#9670;&nbsp;</a></span>count_mutations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mcont_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::count_mutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mcont_t &amp;&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcounts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d0a/spatialts_8cc-example.html#a44">spatialts.cc</a>, and <a class="el" href="../../db/ddb/wfts_8cc-example.html#a45">wfts.cc</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../dd/d23/count__mutations_8hpp_source.html#l00017">17</a> of file <a class="el" href="../../dd/d23/count__mutations_8hpp_source.html">count_mutations.hpp</a>.</p>

</div>
</div>
<a id="af2dbef728e90e485682815dc59ce08b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2dbef728e90e485682815dc59ce08b5">&#9670;&nbsp;</a></span>count_mutations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mcont_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::count_mutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mcont_t &amp;&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>acounts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../dd/d23/count__mutations_8hpp_source.html#l00056">56</a> of file <a class="el" href="../../dd/d23/count__mutations_8hpp_source.html">count_mutations.hpp</a>.</p>

</div>
</div>
<a id="af31b6eea1568ee4866fc66bae4be31ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31b6eea1568ee4866fc66bae4be31ef">&#9670;&nbsp;</a></span>flag_mutations_for_recycling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename poptype , typename mutation_count_container , typename preserve_selected_fixations , typename record_fixations &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::flag_mutations_for_recycling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/df8/spatialts_8cc.html#a7772591e7f617e52a048394158fd7302">poptype</a> &amp;&#160;</td>
          <td class="paramname"><em>pop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_count_container &amp;&#160;</td>
          <td class="paramname"><em>mcounts_from_preserved_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">uint_t</a>&#160;</td>
          <td class="paramname"><em>twoN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">uint_t</a>&#160;</td>
          <td class="paramname"><em>generation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const preserve_selected_fixations&#160;</td>
          <td class="paramname"><em>preserve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const record_fixations&#160;</td>
          <td class="paramname"><em>record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark mutations for recycling.</p>
<p>This function should be called immediately after simplification and mutation counting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pop</td><td>A mutation container </td></tr>
    <tr><td class="paramname">mcounts_from_preserved_nodes</td><td>A container recording the counts of each mutation in ancient samples </td></tr>
    <tr><td class="paramname">twoN</td><td>Twice the current population size </td></tr>
    <tr><td class="paramname">generation</td><td>Current generation/time step in the simulation </td></tr>
    <tr><td class="paramname">preserve</td><td>Policy for handling selected fixations. See below. </td></tr>
    <tr><td class="paramname">record</td><td>Policy for recording fixation events. See below.</td></tr>
  </table>
  </dd>
</dl>
<p>A mutation is marked for recycling if one of the following conditions holds:</p><ol type="1">
<li>The sum of <em>pop.mcounts</em> and <em>mcounts_from_preserved_nodes</em> is zero.</li>
<li><em>pop.mcounts</em> == <em>twoN</em>, mcounts_from_preserved_nodes is zero, and <em>record</em> is std::false_type or the mutation is neutral.</li>
</ol>
<p>Condition 1 refers to extinct mutations and condition 2 refers to fixations.</p>
<p>When <em>preserve</em> is std::true_type, selected fixations are retained in the population. We do this because simulations of phenotypes (as opposed to relative fitness) require tracking the contribution of fixation to trait values.</p>
<p>All variants matching the above criteria have their record in <em>pop.mcounts</em> set to zero and their position is removed from <em>pop.mut_lookup</em>. Further, the mutation's position in <em>pop.mutations</em> is set to std::numeric_limits&lt;double&gt;::max(), to signify an "invalid" mutation.</p>
<p>If <em>record</em> is std::false_type, no fixation recording takes place. However, if <em>record</em> is std::true_type, a record is entered into <em>pop.fixations</em> and <em>pop.fixation_times</em>. If <em>preserve</em> is also std::true_type, the recording is slightly more expensive because we have to guard against repeated recording. For this case, the fixations and fixation times containers in <em>pop</em> are kept sorted by fixation position.</p>
<p>An advanced use of this function is to create branchless code with respect to fixation handling. One can generate a closure wrapping this function with the desired values of <em>preserve</em> and <em>record</em> at the start of a simulation, thus avoiding a bunch of "if" statements prior to each call.</p>
<dl class="section note"><dt>Note</dt><dd>There are several caveats to fixation recording (<em>record</em> == std::true_type). First, it is only as accurate as the time steps between simplifications is small. <em>pop</em> will only contain exact fixation times if simplification occurs every generation. The second limitation is that it will not give correct results if ancient samples are being tracked in a simulation. This has to do with a "todo" item for this function described below. Thus, fixation recording with this function should be considered limited to the case of regular simplification and no ancient sample preservation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The <em>preserve</em> argument needs to be consistent with the desired behavior of <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a98cfaa436a43ae3e8f4ddaee5fac395e" title="Removed fixed variants from gametes. ">ts::remove_fixations_from_gametes</a>.</dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.7.0 Added to library </dd>
<dd>
0.7.1 Updated to change recycled mutation positions to max value of a double. Refactor API to take compile-time policies for fixation handling.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000006">Todo:</a></b></dt><dd><p class="startdd">Improve treatment of fixations by allowing for variants fixed in alive AND ancient samples to be flagged. </p>
<p class="enddd">Return a recycling queue? </p>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d3f/recycling_8hpp_source.html#l00235">235</a> of file <a class="el" href="../../d6/d3f/recycling_8hpp_source.html">recycling.hpp</a>.</p>

</div>
</div>
<a id="a8596f5ad2ff4c7674476e802c285de25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8596f5ad2ff4c7674476e802c285de25">&#9670;&nbsp;</a></span>generate_data_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mcont_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d3a/structfwdpp_1_1data__matrix.html">data_matrix</a> fwdpp::ts::generate_data_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mcont_t &amp;&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>record_neutral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>record_selected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>skip_fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000002">Todo:</a></b></dt><dd>Document </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.7.0 Added to library </dd>
<dd>
0.7.1 Change behavior to skip sites fixed in the sample </dd>
<dd>
0.7.4 Add [start, stop) arguments. Add option to skip fixed variants. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d24/generate__data__matrix_8hpp_source.html#l00019">19</a> of file <a class="el" href="../../df/d24/generate__data__matrix_8hpp_source.html">generate_data_matrix.hpp</a>.</p>

</div>
</div>
<a id="a23bc26c40b07c456d114a8ebaa0008ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bc26c40b07c456d114a8ebaa0008ff">&#9670;&nbsp;</a></span>generate_data_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mcont_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d3a/structfwdpp_1_1data__matrix.html">data_matrix</a> fwdpp::ts::generate_data_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mcont_t &amp;&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>record_neutral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>record_selected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>skip_fixed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d24/generate__data__matrix_8hpp_source.html#l00110">110</a> of file <a class="el" href="../../df/d24/generate__data__matrix_8hpp_source.html">generate_data_matrix.hpp</a>.</p>

</div>
</div>
<a id="a8acb8ff641b41bc320a54cbcf9aa29a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8acb8ff641b41bc320a54cbcf9aa29a3">&#9670;&nbsp;</a></span>generate_offspring()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename genetic_param_holder , typename mutation_handling_policy , typename poptype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="../../d2/d54/structfwdpp_1_1ts_1_1mut__rec__intermediates.html">mut_rec_intermediates</a>, <a class="el" href="../../d2/d54/structfwdpp_1_1ts_1_1mut__rec__intermediates.html">mut_rec_intermediates</a>&gt; fwdpp::ts::generate_offspring </td>
          <td>(</td>
          <td class="paramtype">const gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::size_t, std::size_t &gt;&#160;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_handling_policy &amp;&#160;</td>
          <td class="paramname"><em>mutation_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/df8/spatialts_8cc.html#a7772591e7f617e52a048394158fd7302">poptype</a> &amp;&#160;</td>
          <td class="paramname"><em>pop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genetic_param_holder &amp;&#160;</td>
          <td class="paramname"><em>genetics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="../../d5/d60/classfwdpp_1_1poptypes_1_1slocuspop.html#a77c390c6b7f108b758f9169d9c6664a6">poptype::diploid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>offspring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate offspring gametes and return breakpoints plus mutation keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Random number generator </td></tr>
    <tr><td class="paramname">parents</td><td>Indexes of the offspring parents in <em>pop</em> </td></tr>
    <tr><td class="paramname">mutation_policy</td><td>Either <a class="el" href="../../d8/d48/structfwdpp_1_1ts_1_1all__mutations.html">all_mutations</a> or <a class="el" href="../../de/de4/structfwdpp_1_1ts_1_1selected__variants__only.html">selected_variants_only</a>. See below. </td></tr>
    <tr><td class="paramname">pop</td><td>Either <a class="el" href="../../d5/d60/classfwdpp_1_1poptypes_1_1slocuspop.html" title="Abstraction of what is needed to simulate a single-locus population. ">fwdpp::poptypes::slocuspop</a> or <a class="el" href="../../d3/d57/classfwdpp_1_1poptypes_1_1mlocuspop.html" title="Abstraction of what is needed to simulate a multilocus simulation using an individual-based sampler f...">fwdpp::poptypes::mlocuspop</a>. </td></tr>
    <tr><td class="paramname">genetics</td><td>A duck type of <a class="el" href="../../da/db0/structfwdpp_1_1genetic__parameters.html" title="Hold types for genetic operations. ">fwdpp::genetic_parameters</a>. </td></tr>
    <tr><td class="paramname">offspring</td><td>The offspring for which we will generate gametes.</td></tr>
  </table>
  </dd>
</dl>
<p>The final three parameters will be modified.</p>
<dl class="section return"><dt>Returns</dt><dd>A pair of <a class="el" href="../../d2/d54/structfwdpp_1_1ts_1_1mut__rec__intermediates.html">mut_rec_intermediates</a>, corresponding to what is passed on from each parent.</dd></dl>
<p>The operations are dispatched out to functions based on the population type. These functions make calls to <a class="el" href="../../dd/d84/namespacefwdpp.html#a635801bc8ea29e30cce2e4cf7694bf46">fwdpp::mutate_recombine</a>.</p>
<p>The parameter <em>mutation_policy</em> governs what types of mutations are entered into the gametes of <em>offspring</em>. If the policy is <a class="el" href="../../d8/d48/structfwdpp_1_1ts_1_1all__mutations.html">fwdpp::ts::all_mutations</a>, then neutral and selected variants are placed in an offspring's gametes. If the policy is <a class="el" href="../../de/de4/structfwdpp_1_1ts_1_1selected__variants__only.html">fwdpp::ts::selected_variants_only</a>, then only selected mutations are placed into the gametes. Regardless of the policy, ALL mutations are contained in the return value, with the idea that the caller will record them into a <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">fwdpp::ts::table_collection</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The function type genetic_param_holder::generate_mutations must return std::vector&lt;fwdpp::uint_t&gt;, with the values reflecting the locations of new mutations on <em>pop.mutations</em>. Further, this function must already bind any relevant mutation rates (as this generate_offspring does not accept them as arguments).</dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.7.4 Added to <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html" title="Tree sequence  support. ">fwdpp::ts</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d9c/generate__offspring_8hpp_source.html#l00331">331</a> of file <a class="el" href="../../df/d9c/generate__offspring_8hpp_source.html">generate_offspring.hpp</a>.</p>

</div>
</div>
<a id="a116196377f3b3675bd12951dca7241f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116196377f3b3675bd12951dca7241f3">&#9670;&nbsp;</a></span>get_parent_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>, <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&gt; fwdpp::ts::get_parent_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>first_parental_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>did_swap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert the index of a parent into the two node IDs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_parental_index</td><td>First index of possible parents for offspring </td></tr>
    <tr><td class="paramname">parent</td><td>Index of parent in the population </td></tr>
    <tr><td class="paramname">did_swap</td><td>This is the "Mendel" step.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is trivial in implementation and is easily replaced if a more complex set of rules are needed </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d0a/spatialts_8cc-example.html#a34">spatialts.cc</a>, and <a class="el" href="../../db/ddb/wfts_8cc-example.html#a42">wfts.cc</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../d9/dbe/get__parent__ids_8hpp_source.html#l00012">12</a> of file <a class="el" href="../../d9/dbe/get__parent__ids_8hpp_source.html">get_parent_ids.hpp</a>.</p>

</div>
</div>
<a id="a4e7bf711e7bba2ce46c4cc64c313309e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7bf711e7bba2ce46c4cc64c313309e">&#9670;&nbsp;</a></span>make_mut_queue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flagged_mutation_queue fwdpp::ts::make_mut_queue </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts_from_preserved_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a mutation recycling queue for simulations with tree sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mcounts</td><td>Contribution of extant nodes to mutation counts </td></tr>
    <tr><td class="paramname">counts_from_preserved_nodes</td><td>Contribution of extinct nodes to mutation counts</td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>0.7.0 Added to fwdpp</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>std::queue&lt;std::size_t&gt; </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d4/d99/custom_mutation_8cc-example.html#a20">custom_mutation.cc</a>, <a class="el" href="../../da/db8/juvenile_migration_8cc-example.html#a12">juvenile_migration.cc</a>, <a class="el" href="../../d6/d0a/spatialts_8cc-example.html#a30">spatialts.cc</a>, and <a class="el" href="../../db/ddb/wfts_8cc-example.html#a38">wfts.cc</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../d6/d3f/recycling_8hpp_source.html#l00020">20</a> of file <a class="el" href="../../d6/d3f/recycling_8hpp_source.html">recycling.hpp</a>.</p>

</div>
</div>
<a id="a90ee3318265e92ca462eb292a91d883a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ee3318265e92ca462eb292a91d883a">&#9670;&nbsp;</a></span>make_mut_queue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flagged_mutation_queue fwdpp::ts::make_mut_queue </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>preserved_mutation_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_mutations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a mutation recycling queue for simulations with tree sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preserved_mutation_indexes</td><td>Vector of preserved mutation indexes returned by simplification </td></tr>
    <tr><td class="paramname">num_mutations</td><td>The total number of mutations currently allocated in the population</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::queue&lt;std::size_t&gt;</dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.7.3 Added to fwdpp</dd></dl>
<p>This overload may be preferable to the other when the following conditions apply:</p><ol type="1">
<li>Mutation counts in the entire simulation are not of interest during the simulation.</li>
<li>There is no need/wish to remove fixations from the gametes/tables during the simulation.</li>
<li>There are large numbers of ancient samples being recorded.</li>
</ol>
<p>The first two conditions are required for correct results. The third condition is optional, but big speedups will be seen for that case.</p>
<p>This function generates a recycling queue by taking the set difference of <em>preserved_mutation_indexes</em> and all possible mutation indexes, <img class="formulaInl" alt="$[0,num\_mutations)$" src="../../form_0.png"/>. The algorithm is a fast Nlog(N) method, and it will outperform the other overload based on tree traversal when the number of trees is very large, as is the case when large numbers of ancestral samples are registered during a simulation.</p>
<dl class="section note"><dt>Note</dt><dd>A side-effect is that <em>preserved_mutation_indexes</em> is sorted. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d3f/recycling_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../d6/d3f/recycling_8hpp_source.html">recycling.hpp</a>.</p>

</div>
</div>
<a id="a0e1a2cf7567e8754360c59943adbe18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1a2cf7567e8754360c59943adbe18b">&#9670;&nbsp;</a></span>mark_multiple_roots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>, std::vector&lt;std::pair&lt;double, double&gt; &gt; &gt; fwdpp::ts::mark_multiple_roots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify root nodes in "marginal forests". </p>
<dl class="section version"><dt>Version</dt><dd>0.7.0 Added to library </dd>
<dd>
0.7.4 Refactored to use root tracking method</dd></dl>
<p>See <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a1016e433a6b6390ae0b705cf61dfb1cc" title="Apply a mutation scheme to add neutral mutations to a fwdpp::ts::table_collection. ">fwdpp::ts::mutate_tables</a> for discussion. </p>

<p class="definition">Definition at line <a class="el" href="../../dc/d57/mark__multiple__roots_8hpp_source.html#l00017">17</a> of file <a class="el" href="../../dc/d57/mark__multiple__roots_8hpp_source.html">mark_multiple_roots.hpp</a>.</p>

</div>
</div>
<a id="a1016e433a6b6390ae0b705cf61dfb1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1016e433a6b6390ae0b705cf61dfb1cc">&#9670;&nbsp;</a></span>mutate_tables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename rng , typename mfunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned fwdpp::ts::mutate_tables </td>
          <td>(</td>
          <td class="paramtype">const rng &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfunction &amp;&#160;</td>
          <td class="paramname"><em>make_mutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a mutation scheme to add neutral mutations to a <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">fwdpp::ts::table_collection</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="../../dd/d61/classfwdpp_1_1GSLrng__t.html" title="A wrapper around gsl_rng * objects. ">fwdpp::GSLrng_t</a> </td></tr>
    <tr><td class="paramname">make_mutation</td><td>A mutation function. See below. </td></tr>
    <tr><td class="paramname">tables</td><td>A <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">fwdpp::ts::table_collection</a> </td></tr>
    <tr><td class="paramname">samples</td><td>A list of sample nodes corresponding to "currently-alive" nodes </td></tr>
    <tr><td class="paramname">mu</td><td>Mutation rate (per gamete, per generation)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>0.7.0 Added to library </dd>
<dd>
0.7.2 Return immediately if mutation rate is not &gt; 0</dd></dl>
<p>This function uses the edge_table to apply mutations to all parent/child connections. The mutations should be neutral, although that requirement is not enforced. (It simply makes little sense to apply selected mutations to the entire edge table post-hoc.)</p>
<p>The result of this function is to populate <em>tables.mutation_table</em> with neutral variants.</p>
<p>The parameter <em>make_mutation</em> is a function that must conform to std::function&lt;std::size_t(double, double, fwdpp::uint_t)&gt;. The three arguments are interpreted as "left", "right", and "time". The function's return value corresponds to the index of the new mutation in the simulation's mutation container. The new mutation must have a position on the half-open interval [left, right). The "time" parameger represents the generation when the mutation arose and will be uniformly assigned between the parental birth time and that of the child. This mutation's origin time will be on the half-open interval (parental birth time, child birth time].</p>
<p>The preceding paragraph implies that <em>make_mutation</em> is repsonsible for required operations related to mutation recycling, etc.. The lambda "neutral_variant_maker" in the example program <a class="el" href="../../d9/d59/wfts_8cc.html">wfts.cc</a> will probably be of help here.</p>
<p>It is common that, at the end of a forward-time simulation, that not all trees are completely coalesced. This happens because the distribution on the time to MRCA has very high variance and, due to recombination, some fraction of trees will not be coalesced after, say, 10N generations of evolving a single Wright-Fisher deme. Further, the simlification algorithm will "push" the most ancient nodes on these "marginal forests" forwards in time to the most recent ancestral node of each tree in the forest. Thus, naively mutating the edge table will place too few mutations on these parts of the genome. This function corrects for the presence of marginal forests, as described below.</p>
<p>The <em>samples</em> list is used to identify "marginal forests", meaning marginal trees that are not completely coalesced. (The finding is done via a call to <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a0e1a2cf7567e8754360c59943adbe18b" title="Identify root nodes in &quot;marginal forests&quot;. ">fwdpp::ts::mark_multiple_roots</a>.) The MRCA nodes on trees in marginal forests have additional mutations on them, representing evolution from time point zero (the beginning of the simulation) to the MRCA node's time.</p>
<p>Note that two alternatives exist that will render the treatment of marginal forests unnecessary:</p><ol type="1">
<li>Simulate for longer. For example, CDF of TMRCA under Wright-Fisher is quite close to 1 at ~20N generations. Thus, simulating longer means that fewer and fewer marginal trees will be forests.</li>
<li>Start the simulation with an existing, completely-coalesced, tree sequence. As far as fwdpp is concerned, this is left as an "exercise for the reader" at the moment. </li>
</ol>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d0a/spatialts_8cc-example.html#a40">spatialts.cc</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../db/d16/mutate__tables_8hpp_source.html#l00017">17</a> of file <a class="el" href="../../db/d16/mutate__tables_8hpp_source.html">mutate_tables.hpp</a>.</p>

</div>
</div>
<a id="ab382753de993cedb4e1d14c152868446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab382753de993cedb4e1d14c152868446">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fwdpp::ts::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d3/d70/table__collection_8hpp_source.html#l00417">417</a> of file <a class="el" href="../../d3/d70/table__collection_8hpp_source.html">table_collection.hpp</a>.</p>

</div>
</div>
<a id="a5f05170560f56c1ac6316db842127ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f05170560f56c1ac6316db842127ba6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fwdpp::ts::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d1/d31/mutation__record_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../d1/d31/mutation__record_8hpp_source.html">mutation_record.hpp</a>.</p>

</div>
</div>
<a id="a96dd878eb29e8e1b1fb09e0471f603f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96dd878eb29e8e1b1fb09e0471f603f4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fwdpp::ts::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d3/d09/node_8hpp_source.html#l00026">26</a> of file <a class="el" href="../../d3/d09/node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a1df8628a86608fa402ff6430fc387408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df8628a86608fa402ff6430fc387408">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fwdpp::ts::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d4/ddf/edge_8hpp_source.html#l00027">27</a> of file <a class="el" href="../../d4/ddf/edge_8hpp_source.html">edge.hpp</a>.</p>

</div>
</div>
<a id="a4e79321c58c8dec2eabbb073b689bf4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e79321c58c8dec2eabbb073b689bf4e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fwdpp::ts::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d3/d70/table__collection_8hpp_source.html#l00407">407</a> of file <a class="el" href="../../d3/d70/table__collection_8hpp_source.html">table_collection.hpp</a>.</p>

</div>
</div>
<a id="a98cfaa436a43ae3e8f4ddaee5fac395e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cfaa436a43ae3e8f4ddaee5fac395e">&#9670;&nbsp;</a></span>remove_fixations_from_gametes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gcont_t , typename mcont_t , typename mutation_count_container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::remove_fixations_from_gametes </td>
          <td>(</td>
          <td class="paramtype">gcont_t &amp;&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mcont_t &amp;&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_count_container &amp;&#160;</td>
          <td class="paramname"><em>mcounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_count_container &amp;&#160;</td>
          <td class="paramname"><em>mcounts_from_preserved_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a>&#160;</td>
          <td class="paramname"><em>twoN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>preserve_selected_fixations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removed fixed variants from gametes. </p>
<p>This function should be called immediately after simplification and mutation counting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gametes</td><td>A gamete container </td></tr>
    <tr><td class="paramname">mutations</td><td>A mutation container </td></tr>
    <tr><td class="paramname">mcounts</td><td>A container stating how many times each element in <em>mutations</em> is present in the currently-alive population </td></tr>
    <tr><td class="paramname">mcounts_from_preserved_nodes</td><td>A container recording the counts of each mutation in ancient samples </td></tr>
    <tr><td class="paramname">twoN</td><td>Twice the current population size </td></tr>
    <tr><td class="paramname">preserve_selected_fixations</td><td>If true, do not mark selected fixations for recycling.</td></tr>
  </table>
  </dd>
</dl>
<p>A mutation is removed from a gamete if one of the following conditions holds:</p><ol type="1">
<li>The sum of <em>mcounts</em> and <em>mcounts_from_preserved_nodes</em> is zero.</li>
<li><em>mcounts</em> == <em>twoN</em>, mcounts_from_preserved_nodes is zero, and <em>preserve_selected_fixations</em> is false or the mutation is neutral.</li>
</ol>
<p>When <em>preserve_selected_fixations</em> is true, selected fixations are retained in the population. We do this because simulations of phenotypes (as opposed to relative fitness) require tracking the contribution of fixation to trait values.</p>
<dl class="section note"><dt>Note</dt><dd>When simulating a trait and never simulating neutral mutations, the most efficient thing is to skip calling this function entirely.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The value passed to <em>preserve_selected_fixations</em> needs to be coordinated with the <em>preserve</em> argument of flag_mutations_for_recycling.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000007">Todo:</a></b></dt><dd>Improve treatment of fixations by allowing for variants fixed in alive AND ancient samples to be detected. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/dc7/remove__fixations__from__gametes_8hpp_source.html#l00015">15</a> of file <a class="el" href="../../da/dc7/remove__fixations__from__gametes_8hpp_source.html">remove_fixations_from_gametes.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3b6e884129b83242fc56f14784a2a3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6e884129b83242fc56f14784a2a3d8">&#9670;&nbsp;</a></span>TS_NULL_NODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> fwdpp::ts::TS_NULL_NODE = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index value of a NULL node. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d0a/spatialts_8cc-example.html#a33">spatialts.cc</a>, and <a class="el" href="../../db/ddb/wfts_8cc-example.html#a41">wfts.cc</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../d1/dc9/definitions_8hpp_source.html#l00015">15</a> of file <a class="el" href="../../d1/dc9/definitions_8hpp_source.html">definitions.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
